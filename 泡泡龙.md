# ]泡泡龙代码思路

主要由三块组成：泡泡、箭头、玩家泡泡

```javascript
const shooter = {
        originX: 0,
        originY: 0,
        arrowAngle: Math.PI / 2,
        arrowHeadX: 0,
        arrowHeadY: 0,
        arrowLength: 50,
        arrowHeadLX: 0,
        arrowHeadLY: 0,
        arrowHeadRX: 0,
        arrowHeadRY: 0,
        
    };

const playerBubble = {
        loading: null, //等待发射的泡泡
        nextOne: null //下一个泡泡
    };
```



```javascript
const Grid = class {
        constructor(rows, columns, cellWidth, cellHeight) {      //行数，列数，单元格宽与高
            this.columns = columns;
            this.rows = rows;
            this.cellWidth = cellWidth;
            this.cellHeight = cellHeight;
            this.cells = [];
        }
        //初始化网格为一个二维数组
        init_Grid() {
            for (let i = 0; i <= this.rows - 1; i++) {
                this.cells[i] = [];
            }
        }
        //填充网格单元
        fill() {
            let count = 0;
            let color = randomFrom(0, 6);
            for (let i = 0; i <= this.rows - 1; i++) {
                for (let j = 0; j <= this.columns - 1; j++) {
                    if (i < startRow) {
                        if (count >= 2) {                     //每两个相邻的泡泡颜色相同
                            let preColor = color;
                            color = randomFrom(0, 6);
                            if (color === preColor) {
                                color = (color + 1) % 7
                            }
                            count = 0;
                        }
                        this.cells[i][j] = new Cell(color, "bubble", i, j, 1, true, 0)     //类型为bubble表示该处有泡泡
                    } else {
                        this.cells[i][j] = new Cell(7, "empty", i, j, 1, false, 0)
                    }
                    count++;
                }
            }
        }
    };
```





```javascript
// 网格泡泡类
    const Cell = class {
        constructor(color, type, i, j, transparency, visible, deviation) {
            this.color = color;
            this.type = type;
            this.i = i;
            this.j = j;
            this.transparency = transparency;
            this.visible = visible; 
            this.deviation = deviation;
        }
        //圆心坐标
        getCenter(cellWidth, cellHeight) {
            //奇数行的泡泡相比偶数行的泡泡水平偏移半个单元格大小，在顶部新加入行会影响各行的偏移
            if ((addRowNumber + this.i) % 2 === 0) {
                return ({
                    x: (this.j + 0.5) * cellWidth,
                    y: (this.i + 0.5) * cellHeight + 5         //为了补偿行之间的空隙，单元的宽和高不相等，纵坐标加入5像素
                })
            } else {
                return ({
                    x: (this.j + 1) * cellWidth,
                    y: (this.i + 0.5) * cellHeight + 5
                })
            }
        }
    };
```

 

​    

```javascript
//玩家的泡泡属性类
    const PlayerBubble = class {
        constructor(x, y, prevX, prevY, color, speed = 1000, flyingAngle, trigger, reload) {
            this.x = x;
            this.y = y;
            this.prevX = prevX;
            this.prevY = prevY;
            this.color = color;
            this.speed = speed;
            this.flyingAngle = flyingAngle;
            this.trigger = trigger;
            this.reload = reload;
        }
    };
    

```

​    
​    


​    

init函数初始化鼠标和键盘的监听，进入newGame函数生成基本配置：15x15的网格（只可见6行）、网格单元气泡、玩家气泡、玩家箭头。
开始游戏的主循环mainLoop函数，运行期间不断自动更新画面每帧，每帧的时间里面update函数更新配置，使用render函数渲染页面。（开始时渲染newGame的基本配置）



渲染函数包括渲染：背景、分数、网格及网格上的泡泡、玩家泡泡、发射箭头。每次渲染检查游戏是否结束，结束则渲染游戏结束的页面。

每帧的时间更新包括：

更新发射箭头：根据鼠标所在位置返回坐标，通过坐标与箭头所在的原始坐标计算角度，根据角度来计算组成箭头的三条路径的所在位置来配置箭头的相关属性，等待渲染函数渲染。

更新玩家泡泡：鼠标点击/按压空格才会发生动画效果。鼠标点击后，玩家发射的泡泡会根据发射的时间来更新该泡泡的圆心坐标，然后考虑是否发生碰撞。若碰撞empty忽略；若碰撞左墙壁或右墙壁更新坐标和角度；若碰撞其它，考虑其存在+2的区域，在该区域内检查是否有泡泡和它相交，相交则捕获，调整为对应的网格索引。loading获取nextone泡泡，nextone重新初始化。

更新网格泡泡：只有一个泡泡被捕获时，网格泡泡才会发生动画。

在帧的时间内，查找与该新捕获的泡泡相连且颜色相同的泡泡，若存在3个以上则删除、

查找与该新捕获的泡泡消除后的悬浮泡泡，设置透明度的变化实现动画，然后检查是否游戏结束

若没有消除回合+1





如何确定箭头移动的方向：



初始化时玩家泡泡loading的trigger和reload都为false，鼠标点击时trigger为true且得到对应角度